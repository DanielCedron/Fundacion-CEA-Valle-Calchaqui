<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Editor A4 móvil - Rotado 90° (Landscape fijo)</title>
  <style>
    :root{--page-bg:#fff;--paper-border:#ddd;--accent:#2b8cff}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:#f3f4f6}
    .app{padding:12px;max-width:1200px;margin:0 auto;display:flex;flex-direction:column;align-items:center}

    /* Contenedor que mantiene la hoja A4 pero la rota 90deg para que siempre se muestre "girada" */
    .paper-wrap{display:flex;justify-content:center;align-items:center;overflow:hidden}

    /* La hoja se define en mm (landscape) y luego se rota 90deg visualmente.
       Rotarla hace que el contenido parezca girado como si hubieras rotado el teléfono.
    */
    .paper{
      width:297mm;height:210mm;background:var(--page-bg);box-shadow:0 6px 18px rgba(0,0,0,.12);border:1px solid var(--paper-border);position:relative;touch-action:none;overflow:hidden;display:block;transform:rotate(90deg);transform-origin:center center;
    }

    /* Contenido interior (sin rotación) — para mantener coordenadas lógicas más sencillas
       creamos un inner que contrarota el contenido para que elementos como el editor no queden ilegibles.
       Visualmente la hoja está rota, pero el contenido (texto/inputs) queda legible.
    */
    .paper-inner{position:absolute;inset:0;transform:rotate(-90deg);transform-origin:center center}

    .editor{padding:18mm;box-sizing:border-box;height:100%;outline:none;overflow:auto}
    .editor:empty::before{content:'Pega tu texto aquí...';color:#9aa3b2}

    .img-wrapper{position:absolute;border:2px dashed transparent;box-sizing:border-box;touch-action:none;display:flex;align-items:center;justify-content:center}
    .img-wrapper.selected{border-color:var(--accent)}
    .img-wrapper img{display:block;width:100%;height:100%;object-fit:contain;user-select:none;-webkit-user-drag:none;pointer-events:none}

    /* Mangos: invisibles si no está selected; tamaño aumentado para mejor interacción táctil */
    .img-wrapper .handle{display:none; width:28px;height:28px;border-radius:50%;background:#fff;border:2px solid #666;position:absolute;z-index:30;box-shadow:0 2px 6px rgba(0,0,0,.2);touch-action:none}
    .img-wrapper.selected .handle{display:block}
    .handle.tl{left:-14px;top:-14px}
    .handle.tr{right:-14px;top:-14px}
    .handle.bl{left:-14px;bottom:-14px}
    .handle.br{right:-14px;bottom:-14px}

    /* Aumentar área táctil real sin mostrar extra visual mediante pseudo-elementos */
    .handle::after{content:'';position:absolute;inset:-12px;border-radius:50%}

    .confirm-btn{position:absolute;right:10px;bottom:10px;width:56px;height:56px;border-radius:50%;background:var(--accent);display:flex;align-items:center;justify-content:center;color:#fff;font-size:28px;box-shadow:0 6px 18px rgba(43,140,255,.25);z-index:200}
    .confirm-btn.hidden{display:none}

    .controls{display:flex;gap:8px;margin-top:12px;align-items:center}
    button.primary{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:10px;font-size:16px}

    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center;z-index:400}
    .modal{background:#fff;border-radius:12px;padding:18px;min-width:260px;max-width:95%;box-shadow:0 8px 30px rgba(0,0,0,.3)}

    /* Ocultar elementos visibles durante exportación */
    .exporting .img-wrapper{border-color:transparent !important}
    .exporting .img-wrapper .handle{display:none !important}

    @media (max-width:520px){
      .app{padding:8px}
      /* contener la hoja girada dentro del viewport */
      .paper{width:96vw;height:calc(96vw * 210 / 297)}
    }
  </style>
</head>
<body>
  <div class="app">
    <div style="display:flex;justify-content:space-between;align-items:center;width:100%">
      <h2>Editor A4 móvil (rotado 90°)</h2>
      <div class="controls">
        <button id="exportPdf" class="primary">Convertir PDF</button>
      </div>
    </div>

    <div class="paper-wrap" style="width:100%;display:flex;justify-content:center;align-items:center;margin-top:12px;">
      <div id="paper" class="paper" aria-label="Hoja A4 rotada">
        <div class="paper-inner">
          <div id="editor" class="editor" contenteditable="true"></div>
        </div>
      </div>
    </div>

    <button id="confirmBtn" class="confirm-btn hidden">✓</button>
    <input id="fileInput" type="file" accept="image/*" style="display:none">

    <div id="modal" class="modal-backdrop" style="display:none">
      <div class="modal" id="modalContent">
        <h3 id="modalTitle">Agregar imagen</h3>
        <div id="modalBody"></div>
        <div style="display:flex;justify-content:flex-end;margin-top:12px">
          <button id="modalCancel">Cancelar</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const paper = document.getElementById('paper');
    const paperInner = document.querySelector('.paper-inner');
    const editor = document.getElementById('editor');
    const fileInput = document.getElementById('fileInput');
    const modal = document.getElementById('modal');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    const modalCancel = document.getElementById('modalCancel');
    const confirmBtn = document.getElementById('confirmBtn');

    let pressTimer = null; let longPressActive=false; let touchStartedOnEditor=false;

    function showModal(title, bodyHtml){ modalTitle.textContent = title; modalBody.innerHTML = bodyHtml; modal.style.display='flex'; }
    function hideModal(){ modal.style.display='none'; editor.contentEditable='true'; }

    // Mapear coordenadas táctiles teniendo en cuenta que la hoja está rotada 90deg (visual)
    function mapTouchToPaper(touch){
      const pr = paper.getBoundingClientRect();
      // centro
      const cx = pr.left + pr.width/2;
      const cy = pr.top + pr.height/2;
      const dx = touch.clientX - cx;
      const dy = touch.clientY - cy;
      // rotar -90deg (contrarresta la rotación CSS de +90deg)
      const rx = dy; // cos0*dx - sin(-90)*dy => dy
      const ry = -dx; // sin(-90)*dx + cos(-90)*dy => -dx
      const mappedX = cx + rx; const mappedY = cy + ry;
      return {x: mappedX, y: mappedY, parentRect: pr};
    }

    paper.addEventListener('touchstart', e=>{
      if (e.touches.length>1) return;
      const t = e.touches[0];
      const mapped = mapTouchToPaper(t);
      longPressActive = false;
      // detectar si tocó el editor interior
      const el = document.elementFromPoint(t.clientX, t.clientY);
      touchStartedOnEditor = !!el && !!el.closest && !!el.closest('#editor');

      if (touchStartedOnEditor && !el.closest('.img-wrapper') && !el.classList.contains('handle')){
        e.preventDefault(); editor.blur();
      }

      pressTimer = setTimeout(()=>{
        longPressActive = true;
        showModal('Agregar imagen', '<div class="row">Pulsa "Agregar imagen" para seleccionar una foto desde tu dispositivo.</div>'+
          '<div style="display:flex;justify-content:center;margin-top:12px"><button id="modalAddImage" class="primary">Agregar imagen</button></div>');
        editor.contentEditable='false';
        const btn = document.getElementById('modalAddImage'); if (btn) btn.addEventListener('click', ()=>fileInput.click());
      }, 800); // tiempo reducido a 800ms para mejor UX
    });

    paper.addEventListener('touchend', e=>{
      if (pressTimer){ clearTimeout(pressTimer); pressTimer = null; }
      if (longPressActive){ longPressActive=false; return; }
      if (touchStartedOnEditor){ editor.contentEditable='true'; editor.focus(); }
      touchStartedOnEditor=false;
    });
    paper.addEventListener('touchmove', e=>{ if (pressTimer){ clearTimeout(pressTimer); pressTimer=null; }});

    modalCancel.addEventListener('click', hideModal);
    modal.addEventListener('click', ev=>{ if (ev.target===modal) hideModal(); });

    fileInput.addEventListener('change', ev=>{ hideModal(); const file = ev.target.files && ev.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); addImageToPaper(url); fileInput.value=''; });

    let zIndexCounter=10; function addImageToPaper(src){
      const wrapper = document.createElement('div'); wrapper.className='img-wrapper';
      // posición centrada por defecto en mm
      wrapper.style.left='20mm'; wrapper.style.top='40mm'; wrapper.style.width='60mm'; wrapper.style.height='60mm'; wrapper.style.zIndex = zIndexCounter++;
      const img = document.createElement('img'); img.src = src; wrapper.appendChild(img);
      ['tl','tr','bl','br'].forEach(pos=>{ const h=document.createElement('div'); h.className='handle '+pos; wrapper.appendChild(h); });
      // añadir al paperInner (coordenadas lógicas)
      paperInner.appendChild(wrapper);
      makeInteractive(wrapper);
      selectWrapper(wrapper);
    }

    let selectedWrapper = null;
    function selectWrapper(w){ if (selectedWrapper && selectedWrapper!==w) deselectWrapper(selectedWrapper); selectedWrapper = w; w.classList.add('selected'); showConfirmBtnForWrapper(w); }
    function deselectWrapper(w){ if (!w) return; w.classList.remove('selected'); if (selectedWrapper===w) selectedWrapper=null; hideConfirmBtn(); }

    function showConfirmBtnForWrapper(w){ confirmBtn.classList.remove('hidden'); confirmBtn.style.right='10px'; confirmBtn.style.bottom='10px'; confirmBtn.onclick = ()=>{ deselectWrapper(w); }; }
    function hideConfirmBtn(){ confirmBtn.classList.add('hidden'); confirmBtn.onclick = null; }

    // click to select
    paper.addEventListener('click', e=>{ const el = e.target; const wrapper = el.closest && el.closest('.img-wrapper'); if (wrapper){ selectWrapper(wrapper); } else { if (selectedWrapper) deselectWrapper(selectedWrapper); } });

    // Interacción: drag (centra la imagen bajo el dedo) y resize más tolerante
    function makeInteractive(wrapper){
      const handles = wrapper.querySelectorAll('.handle');
      let mode=null; let start={}; let orig={};

      // drag start: intentamos centrar la imagen bajo el dedo
      wrapper.addEventListener('touchstart', ev=>{
        ev.stopPropagation(); const t = ev.touches[0]; const el = document.elementFromPoint(t.clientX, t.clientY);
        if (el && el.classList && el.classList.contains('handle')) return; // handle lo maneja resize
        mode='drag';
        const mapped = mapTouchToPaper(t);
        const pr = mapped.parentRect;
        const r = wrapper.getBoundingClientRect();
        // coordenadas relativas a paperInner (top-left)
        const leftPx = r.left - pr.left; const topPx = r.top - pr.top;
        orig = {width: r.width, height: r.height};
        start = {mappedX: mapped.x, mappedY: mapped.y};
        wrapper.style.zIndex = zIndexCounter++;
        selectWrapper(wrapper);
      });

      wrapper.addEventListener('touchmove', ev=>{
        if (mode!=='drag') return; ev.preventDefault(); ev.stopPropagation(); const t = ev.touches[0]; const mapped = mapTouchToPaper(t); const pr = mapped.parentRect;
        // Queremos que el centro del wrapper coincida con mapped point
        const centerX = mapped.x - pr.left; const centerY = mapped.y - pr.top;
        const newLeftPx = centerX - (orig.width/2); const newTopPx = centerY - (orig.height/2);
        wrapper.style.left = pxToMm(newLeftPx, pr.width) + 'mm'; wrapper.style.top = pxToMm(newTopPx, pr.height) + 'mm';
      });
      wrapper.addEventListener('touchend', ev=>{ mode=null; });

      // Resize usando distancia centro-TOUCH para escala uniforme (más natural en táctil)
      handles.forEach(h=>{
        h.addEventListener('touchstart', ev=>{
          ev.stopPropagation(); ev.preventDefault(); mode='resize'; const t = ev.touches[0]; const mapped = mapTouchToPaper(t); const pr = mapped.parentRect;
          const r = wrapper.getBoundingClientRect(); const centerX = r.left - pr.left + r.width/2; const centerY = r.top - pr.top + r.height/2;
          const dx = mapped.x - (pr.left + centerX); const dy = mapped.y - (pr.top + centerY);
          const startDist = Math.hypot(dx, dy);
          orig = {width: r.width, height: r.height, centerX: centerX, centerY: centerY, startDist: startDist};
          wrapper.style.zIndex = zIndexCounter++;
          selectWrapper(wrapper);
        });
        h.addEventListener('touchmove', ev=>{
          if (mode!=='resize') return; ev.stopPropagation(); ev.preventDefault(); const t = ev.touches[0]; const mapped = mapTouchToPaper(t); const pr = mapped.parentRect;
          const cx = pr.left + orig.centerX; const cy = pr.top + orig.centerY;
          const ndx = mapped.x - cx; const ndy = mapped.y - cy; const newDist = Math.hypot(ndx, ndy);
          const ratio = Math.max(0.2, newDist / (orig.startDist || 1));
          let newW = Math.max(30, orig.width * ratio); let newH = Math.max(30, orig.height * ratio);
          // ajustar para mantener centro en el mismo lugar
          const newLeftPx = orig.centerX - newW/2; const newTopPx = orig.centerY - newH/2;
          wrapper.style.width = pxToMm(newW, pr.width) + 'mm'; wrapper.style.height = pxToMm(newH, pr.height) + 'mm';
          wrapper.style.left = pxToMm(newLeftPx, pr.width) + 'mm'; wrapper.style.top = pxToMm(newTopPx, pr.height) + 'mm';
        });
        h.addEventListener('touchend', ev=>{ mode=null; });
      });

      wrapper.addEventListener('click', e=>{ e.stopPropagation(); selectWrapper(wrapper); });
    }

    function pxToMm(px, parentPxWidth){ const mmPerPx = 297 / parentPxWidth; return (px * mmPerPx).toFixed(2); }

    document.getElementById('exportPdf').addEventListener('click', ()=>{
      showModal('Guardar PDF', '<div class="row">Ponle un nombre al archivo:</div>'+
        '<div class="row" style="margin-top:8px"><input id="fileName" type="text" placeholder="mi-documento" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:8px"></div>'+
        '<div style="display:flex;justify-content:space-between;margin-top:12px"><button id="modalCancel2">Cancelar</button><button id="modalDownload" class="primary">Descargar</button></div>');
      const dl = document.getElementById('modalDownload'); const cancel2 = document.getElementById('modalCancel2');
      if (dl) dl.addEventListener('click', async ()=>{ const filename = (document.getElementById('fileName').value || 'documento') + '.pdf'; hideModal(); await exportPaperToPdf(filename); }, {once:true});
      if (cancel2) cancel2.addEventListener('click', hideModal, {once:true});
    });

    async function exportPaperToPdf(filename){
      const wrappers = Array.from(paperInner.querySelectorAll('.img-wrapper'));
      wrappers.forEach(w=>w.classList.remove('selected'));
      hideConfirmBtn(); paper.classList.add('exporting');
      try{
        const scale = Math.min(3, window.devicePixelRatio || 2);
        const canvas = await html2canvas(paper, {scale:scale, useCORS:true, allowTaint:true});
        const imgData = canvas.toDataURL('image/jpeg', 0.95);
        const { jsPDF } = window.jspdf; const pdf = new jsPDF({unit:'mm', format:'a4', orientation:'landscape'});
        pdf.addImage(imgData, 'JPEG', 0, 0, 297, 210);
        pdf.save(filename);
      }catch(err){ alert('Error al generar PDF: '+(err && err.message? err.message: err)); }
      finally{ paper.classList.remove('exporting'); }
    }

  </script>
</body>
</html>
